http://www.analogmuseum.org/library/handbook_of_analog_computation.pdf
https://zwischenzugs.com/2019/03/25/aws-vs-k8s-is-the-new-windows-vs-linux/
http://dl.lateralis.org/public/sagebook/sagebook-ba6596d.pdf

My rationale behind this approach for estimation:

Traditionally, software was viewed as an assemblage of processng components. But from the API perspective, I view software as a set of pure interactions. Because I think that APIs are the substrate which facilitate interactions between information processing components, that is - humnas, databases and back-end systems, whose behaviors are assumed to be already defined (implemented). I view data read/write as transformations on the message template which is part of interactions. 

Thus, most of the effort in API imlementations is spent on preparing the requests, transforming the responses and handling the data formats. Accordingly I have selected these as the parapmeters that influence the estimates.

-----

import math


def fact(n):
	res = 1
	for i in range(2,n+1):
		res *= i
	return res

def ncr(n, r):
	return fact(n)/(fact(n-r)*fact(r))

bn = []
bn.append(1.0)

for i in range(0,50):
	sum = 0.0
	for k in range(len(bn)):
		sum += bn[k]*ncr(len(bn)+1, k)
	b = (0-sum)/(len(bn)+1)
	if abs(b) < 1.0e-08:
		b = 0
	bn.append(b)

for i in range(0, len(bn), 2):
	print (bn[i])

---------------
-----------------------------------

 n^x = (1 + xlogn/k)^k
 = 1 + (k,1) (xlogn/k) + (k,2) (xlogn/k)^2 + (k,3) (xlogn/k)^3 + ... + (xlogn/k)^k

 sum (n:2->c) ((logn)^k) = c ( (logc)^k - k(logc)^k-1 + k(k-1)(logc)^k-2 + ... + k!)

 sum (n:2->c) (n^x) = 

 c (1 + (k,m) (x/k)^k * ( (logc)^k - k(logc)^k-1 + k(k-1)(logc)^k-2  ) )

 c (1 + (k,m) (x/k)^k * (logc)^k (1 - k(logc)^-1 ) )

 c (1 + axlogc/k)^k   ;   (1 - k(logc)^-1) = a^k

 a^k = (1 - k(logc)^-1)
 
 a = (1 - k(logc)^-1)^(1/k)
 
--------------------------------
 
 c (1 + axlogc/k)^k = -1
 
 (1 + axlogc/k)^k = -1/c

 axlogc/k = (-1/c)^(1/k)
 
 --------------
 
import math

c = 1e+12
#m = 5

for m in range (1000,1010):
	sum = 0.0
	v = 1
	sum = 1
	for i in range (m):
#		v *= (m-i) / math.log(c)
		v *= (m-i) / m
		sum += (-1)**(i+1) * v
	print (sum)


#x( (logx)^1 - 1)
#x( (logx)^2 - 2*(logx) + 2*1)
#x( (logx)^3 - 3*(logx)^2 + 3*2*(logx) - 3*2*1)
#x( (logx)^4 - 4*(logx)^3 + 4*3*(logx)^2 - 4*3*2*(logx) + 4*3*2*1)

#x(logx)^4 ( 1 - 4/(logx) + 4*3/(logx)^2 - 4*3*2/(logx)^3 + 4*3*2*1/(logx)^4)
#x(logx)^3 ( 1 - 3/(logx) + 3*2/(logx)^2 - 3*2*1/(logx)^3)
#x(logx)^2 ( 1 - 2/(logx) + 2*1/(logx)^2)
#x(logx)^1 ( 1 - 1/(logx))

# 1 - 4/(logx) + 4*3/(logx)^2 - 4*3*2/(logx)^3 + 4*3*2*1/(logx)^4
------------
http://go.helms-net.de/math/binomial/zeta_bernoulli.pdf



 
  
 x = (-1/c)^(1/k) * k/(alogc)

 x = (-1/c)^(1/k) * k/ (logc * (1 - k(logc)^-1)^(1/k) )

 x = (k/logc) * (-1/c)^(1/k) * (1 - k(logc)^-1)^(1/k) 

 x = (k/logc) * (-1/c)^(1/k) * (1 - k/(logc))^(1/k) 

 x = (k/logc) * ( (-1/c) * (1 - k/(logc)) )^(1/k) 

--------------------------------
 



